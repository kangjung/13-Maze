<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>js13kgame - 미로 게임</title>
    <style>
        body {
            text-align: center;
            font-family: Arial, sans-serif;
            background-color: black;
        }
        #gameCanvas {
            border: 1px solid black;
            margin: 20px auto;
            display: block;
            background-color: #f0f0f0;
        }
        #gameInfo {
            display: flex;
            justify-content: center;
            gap: 20px;
            color: white;
        }
        #optionContainer {
            display: none;
            flex-direction: column;
            align-items: center;
            position: absolute;
            background-color: white;
            padding: 20px;
            border: 1px solid black;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        button {
            margin: 10px;
        }
    </style>
</head>
<body>
<h1 style="color:white;">미로 게임</h1>
<canvas id="gameCanvas" width="600" height="600"></canvas>
<div id="gameInfo">
    <p>점수: <span id="score">0</span></p>
    <p>체력: <span id="health">10</span></p>
    <p>힌트: <span id="hints">3</span></p>
    <p id="gameStatus"></p>
</div>
<div id="optionContainer">
    <button onclick="move()">이동</button>
    <button onclick="useHint()">힌트 사용</button>
    <button onclick="cancel()">취소</button>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const context = canvas.getContext('2d');
    const tileSize = 60; // 타일 크기
    const mazeSize = 10; // 미로 크기
    const tiles = [];
    const playerPosition = { row: 0, col: 0 };
    const endTile = { row: mazeSize - 1, col: mazeSize - 1 };
    let currentScore = 0;
    let playerHealth = 10;
    let hintsAvailable = 3;
    let selectedTile = null;

    const sprite = new Image();
    sprite.src = './asset/sprite.png'; // 스프라이트 이미지 경로

    sprite.onload = function() {
        initializeMaze();
    };

    sprite.onerror = function() {
        console.error('스프라이트 이미지를 로드할 수 없습니다.');
    };

    function initializeMaze() {
        for (let row = 0; row < mazeSize; row++) {
            tiles[row] = [];
            for (let col = 0; col < mazeSize; col++) {
                tiles[row][col] = {
                    x: col * tileSize,
                    y: row * tileSize,
                    wall: Math.random() < 0.2, // 벽 확률
                    revealed: false,
                    moveable: false,
                    score: Math.floor(Math.random() * 7) - 3 // -3부터 3까지의 점수
                };
            }
        }

        tiles[endTile.row][endTile.col].wall = false;
        tiles[playerPosition.row][playerPosition.col].wall = false;

        createMaze();
        drawMaze(); // 타일을 그린 후
        updateMoveableTiles(); // 타일 업데이트
    }

    function drawMaze() {
        context.fillStyle = 'black';
        context.fillRect(0, 0, canvas.width, canvas.height);

        const visibleRange = 2; // 시야 범위
        for (let row = 0; row < mazeSize; row++) {
            for (let col = 0; col < mazeSize; col++) {
                const tile = tiles[row][col];
                const isVisible = isTileVisible(row, col, visibleRange);
                if (isVisible) {
                    if (row === endTile.row && col === endTile.col) {
                        context.drawImage(sprite, 0, 0, 16, 16, tile.x, tile.y, tileSize, tileSize);
                    } else if (tile.wall) {
                        // 시야 내 벽을 그립니다.
                        context.drawImage(sprite, 16, 0, 16, 16, tile.x, tile.y, tileSize, tileSize);
                    } else {
                        // 시야 내 길을 그립니다.
                        context.drawImage(sprite, 32, 0, 16, 16, tile.x, tile.y, tileSize, tileSize);

                        // 타일의 점수 표시
                        if (tile.score !== 0) {
                            context.fillStyle = tile.score > 0 ? 'green' : 'red'; // 점수에 따라 색상 결정
                            context.font = '20px Arial';
                            context.textAlign = 'center';
                            context.fillText(tile.score, tile.x + tileSize / 2, tile.y + tileSize / 2 + 8); // 점수를 중앙에 표시
                        }
                    }

                    // 이동 가능한 타일 강조 표시
                    if (tile.moveable) {
                        context.strokeStyle = 'yellow';
                        context.lineWidth = 2;
                        context.strokeRect(tile.x, tile.y, tileSize, tileSize);
                    }
                } else {
                    // 시야 밖의 타일은 검정색으로 표시
                    context.fillStyle = 'black';
                    context.fillRect(tile.x, tile.y, tileSize, tileSize);
                }
            }
        }

        // 플레이어 표시
        context.fillStyle = 'yellow';
        context.beginPath();
        context.arc(playerPosition.col * tileSize + tileSize / 2, playerPosition.row * tileSize + tileSize / 2, tileSize / 4, 0, 2 * Math.PI);
        context.fill();
        context.stroke();
    }

    function isTileVisible(row, col, range) {
        const dx = Math.abs(playerPosition.col - col);
        const dy = Math.abs(playerPosition.row - row);
        return dx <= range && dy <= range;
    }

    function createMaze() {
        function isValid(row, col) {
            return row >= 0 && row < mazeSize && col >= 0 && col < mazeSize;
        }

        function hasPath() {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            const queue = [playerPosition];
            const visited = new Set([`${playerPosition.row},${playerPosition.col}`]);

            while (queue.length > 0) {
                const { row, col } = queue.shift();
                if (row === endTile.row && col === endTile.col) return true;
                for (const [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (isValid(newRow, newCol) && !tiles[newRow][newCol].wall && !visited.has(`${newRow},${newCol}`)) {
                        visited.add(`${newRow},${newCol}`);
                        queue.push({ row: newRow, col: newCol });
                    }
                }
            }
            return false;
        }

        let tries = 0;
        const maxTries = 1000;
        while (!hasPath() && tries < maxTries) {
            for (let row = 0; row < mazeSize; row++) {
                for (let col = 0; col < mazeSize; col++) {
                    if (!(row === playerPosition.row && col === playerPosition.col) && !(row === endTile.row && col === endTile.col)) {
                        tiles[row][col].wall = Math.random() < 0.3; // 30% 확률로 벽 생성
                    }
                }
            }
            tries++;
        }
    }

    function updateMoveableTiles() {
        for (let row = 0; row < mazeSize; row++) {
            for (let col = 0; col < mazeSize; col++) {
                tiles[row][col].moveable = false; // 기본적으로 이동 불가능
            }
        }

        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
        for (const [dr, dc] of directions) {
            const newRow = playerPosition.row + dr;
            const newCol = playerPosition.col + dc;
            if (newRow >= 0 && newRow < mazeSize && newCol >= 0 && newCol < mazeSize && !tiles[newRow][newCol].wall) {
                tiles[newRow][newCol].moveable = true;
            }
        }
        drawMaze();
    }

    function move() {
        if (selectedTile && tiles[selectedTile.row][selectedTile.col].moveable) {
            tiles[playerPosition.row][playerPosition.col].revealed = true;
            playerPosition.row = selectedTile.row;
            playerPosition.col = selectedTile.col;

            const tileScore = tiles[selectedTile.row][selectedTile.col].score;
            currentScore += tileScore;
            playerHealth += tileScore > 0 ? 1 : -1;

            document.getElementById('score').innerText = currentScore;
            document.getElementById('health').innerText = playerHealth;

            drawMaze(); // 이동 후 미로를 먼저 그림

            if (tileScore !== 0) {
                displayPixelatedScoreEffect(tileScore); // 점수 효과 표시
            }

            if (playerPosition.row === endTile.row && playerPosition.col === endTile.col) {
                document.getElementById('gameStatus').innerText = "축하합니다! 미로를 탈출했습니다!";
                document.getElementById('optionContainer').style.display = 'none';
            } else if (playerHealth <= 0) {
                document.getElementById('gameStatus').innerText = "게임 오버! 체력이 모두 소진되었습니다.";
                document.getElementById('optionContainer').style.display = 'none';
            } else {
                updateMoveableTiles();
                document.getElementById('optionContainer').style.display = 'none';
            }

            selectedTile = null;
        }
    }

    function displayPixelatedScoreEffect(tileScore) {
        const text = tileScore > 0 ? `+${tileScore}` : `${tileScore}`;
        const color = tileScore > 0 ? 'lime' : 'red';

        console.log('Displaying pixelated score:', text, 'with color:', color);

        const tempCanvas = document.createElement('canvas');
        const tempContext = tempCanvas.getContext('2d');
        const fontSize = 300;
        tempCanvas.width = 600;
        tempCanvas.height = 400;

        tempContext.font = `bold ${fontSize}px Arial`;
        tempContext.fillStyle = color;
        tempContext.textAlign = 'center';
        tempContext.textBaseline = 'middle';

        tempContext.fillText(text, tempCanvas.width / 2, tempCanvas.height / 2);

        const imageData = tempContext.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        for (let i = 0; i < imageData.data.length; i += 4) {
            if (imageData.data[i + 3] > 128) {
                const rand = Math.random();
                if (rand > 0.8) {
                    imageData.data[i + 3] = 0;
                }
            }
        }
        tempContext.putImageData(imageData, 0, 0);

        context.drawImage(tempCanvas, canvas.width / 2 - tempCanvas.width / 2, canvas.height / 2 - tempCanvas.height / 2);

        let alpha = 1.0; // 투명도 초기값
        const fadeOut = setInterval(() => {
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.globalAlpha = alpha;
            drawMaze();
            context.drawImage(tempCanvas, canvas.width / 2 - tempCanvas.width / 2, canvas.height / 2 - tempCanvas.height / 2);
            alpha -= 0.1;
            if (alpha <= 0) {
                clearInterval(fadeOut);
                context.globalAlpha = 1.0;
                drawMaze();
                updateMoveableTiles();
            }
        }, 100);
    }


    function useHint() {
        if (hintsAvailable > 0) {
            hintsAvailable--;
            document.getElementById('hints').innerText = hintsAvailable.toString();
            revealSurroundingTiles(playerPosition.row, playerPosition.col, 1);
            drawMaze();
        } else {
            alert("더 이상 힌트를 사용할 수 없습니다.");
        }
    }

    function revealSurroundingTiles(row, col, range) {
        for (let r = row - range; r <= row + range; r++) {
            for (let c = col - range; c <= col + range; c++) {
                if (r >= 0 && r < mazeSize && c >= 0 && c < mazeSize && !tiles[r][c].wall) {
                    tiles[r][c].revealed = true;
                }
            }
        }
    }

    function cancel() {
        document.getElementById('optionContainer').style.display = 'none';
        selectedTile = null;
    }

    function onClick(event) {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const col = Math.floor(x / tileSize);
        const row = Math.floor(y / tileSize);

        if (row >= 0 && row < mazeSize && col >= 0 && col < mazeSize) {
            const tile = tiles[row][col];
            if (tile.moveable) {
                selectedTile = { row, col };
                const optionContainer = document.getElementById('optionContainer');
                optionContainer.style.left = `${event.clientX}px`;
                optionContainer.style.top = `${event.clientY}px`;
                optionContainer.style.display = 'flex';
            }
        }
    }

    canvas.addEventListener('click', onClick);
</script>
</body>
</html>
