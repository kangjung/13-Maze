<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>js13kgame - 미로 게임</title>
    <style>
        body {
            text-align: center;
            font-family: Arial, sans-serif;
            background-color: black;
        }
        #gameCanvas {
            border: 1px solid black;
            margin: 20px auto;
            display: block;
            background-color: #f0f0f0;
        }
        #gameInfo {
            display: flex;
            justify-content: center;
            gap: 20px;
            color: white;
        }
        #optionContainer {
            display: none;
            flex-direction: column;
            align-items: center;
            position: absolute;
            background-color: white;
            padding: 20px;
            border: 1px solid black;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.3);
        }
        button {
            margin: 10px;
        }
    </style>
</head>
<body>
<h1 style="color:white;">미로 게임</h1>
<canvas id="gameCanvas" width="600" height="600"></canvas>
<div id="gameInfo">
    <p>점수: <span id="score">0</span></p>
    <p>체력: <span id="health">10</span></p>
    <p>힌트: <span id="hints">3</span></p>
    <p id="gameStatus"></p>
</div>
<div id="optionContainer">
    <button onclick="move()">이동</button>
    <button onclick="useHint()">힌트 사용</button>
    <button onclick="cancel()">취소</button>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const context = canvas.getContext('2d');
    const tileSize = 60; // 타일 크기
    const mazeSize = 10; // 미로 크기
    const tiles = [];
    const playerPosition = { row: 0, col: 0 };
    const endTile = { row: mazeSize - 1, col: mazeSize - 1 };
    let currentScore = 0;
    let playerHealth = 10;
    let hintsAvailable = 3;
    let selectedTile = null;

    function initializeMaze() {
        for (let row = 0; row < mazeSize; row++) {
            tiles[row] = [];
            for (let col = 0; col < mazeSize; col++) {
                tiles[row][col] = {
                    x: col * tileSize,
                    y: row * tileSize,
                    wall: Math.random() < 0.2, // 벽 확률
                    revealed: false,
                    moveable: false,
                    score: Math.floor(Math.random() * 7) - 3 // -3부터 3까지의 점수
                };
            }
        }

        tiles[endTile.row][endTile.col].wall = false;
        tiles[playerPosition.row][playerPosition.col].wall = false;

        createMaze();
        drawMaze();
        updateMoveableTiles();
    }

    function drawMaze() {
        context.clearRect(0, 0, canvas.width, canvas.height);

        const visibleRange = 2; // 시야 범위
        for (let row = 0; row < mazeSize; row++) {
            for (let col = 0; col < mazeSize; col++) {
                const tile = tiles[row][col];
                if (isTileVisible(row, col, visibleRange)) {
                    const fillColor = getTileColor(tile, row, col);
                    context.fillStyle = fillColor;
                    context.fillRect(tile.x, tile.y, tileSize, tileSize);
                    context.strokeRect(tile.x, tile.y, tileSize, tileSize);

                    if (!tile.wall && tile.score !== 0 && !tile.revealed) {
                        context.fillStyle = 'blue';
                        context.font = "20px Arial";
                        context.textAlign = "center";
                        context.textBaseline = "middle";
                        context.fillText(tile.score, tile.x + tileSize / 2, tile.y + tileSize / 2);
                    }
                } else {
                    context.fillStyle = 'black'; // 시야에 없는 타일을 검정색으로 처리
                    context.fillRect(tile.x, tile.y, tileSize, tileSize);
                    context.strokeRect(tile.x, tile.y, tileSize, tileSize);
                }
            }
        }

        // 플레이어 표시
        context.fillStyle = 'yellow';
        context.beginPath();
        context.arc(playerPosition.col * tileSize + tileSize / 2, playerPosition.row * tileSize + tileSize / 2, tileSize / 4, 0, 2 * Math.PI);
        context.fill();
        context.stroke();

        // 출구 표시
        context.fillStyle = 'red';
        context.fillRect(endTile.col * tileSize, endTile.row * tileSize, tileSize, tileSize);
    }

    function isTileVisible(row, col, range) {
        if (row === playerPosition.row && col === playerPosition.col) {
            return true;
        }
        const dx = Math.abs(playerPosition.col - col);
        const dy = Math.abs(playerPosition.row - row);
        if (dx <= range && dy <= range) {
            return !isBlockedByWall(playerPosition.row, playerPosition.col, row, col);
        }
        return false;
    }

    function isBlockedByWall(startRow, startCol, endRow, endCol) {
        const dx = endCol - startCol;
        const dy = endRow - startRow;
        const steps = Math.max(Math.abs(dx), Math.abs(dy));
        const xIncrement = dx / steps;
        const yIncrement = dy / steps;

        let x = startCol;
        let y = startRow;

        for (let i = 0; i <= steps; i++) {
            const row = Math.round(y);
            const col = Math.round(x);
            if (row >= 0 && row < mazeSize && col >= 0 && col < mazeSize && tiles[row][col].wall) {
                return true;
            }
            x += xIncrement;
            y += yIncrement;
        }
        return false;
    }

    function getTileColor(tile, row, col) {
        if (row === endTile.row && col === endTile.col) {
            return 'red';
        } else if (tile.wall) {
            return 'darkgray'; // 벽은 어두운 회색으로
        } else if (tile.revealed) {
            return 'lightyellow'; // 이동한 타일은 밝은 노란색
        } else if (tile.moveable) {
            return 'lightgreen'; // 이동 가능한 타일은 밝은 녹색
        } else {
            return 'lightgray'; // 기본 색상
        }
    }

    function createMaze() {
        function isValid(row, col) {
            return row >= 0 && row < mazeSize && col >= 0 && col < mazeSize;
        }

        function hasPath() {
            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            const queue = [playerPosition];
            const visited = new Set([`${playerPosition.row},${playerPosition.col}`]);

            while (queue.length > 0) {
                const { row, col } = queue.shift();
                if (row === endTile.row && col === endTile.col) return true;
                for (const [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (isValid(newRow, newCol) && !tiles[newRow][newCol].wall && !visited.has(`${newRow},${newCol}`)) {
                        visited.add(`${newRow},${newCol}`);
                        queue.push({ row: newRow, col: newCol });
                    }
                }
            }
            return false;
        }

        let tries = 0;
        const maxTries = 1000;
        while (!hasPath() && tries < maxTries) {
            for (let row = 0; row < mazeSize; row++) {
                for (let col = 0; col < mazeSize; col++) {
                    if (!(row === playerPosition.row && col === endTile.col) && !(row === endTile.row && col === endTile.col)) {
                        tiles[row][col].wall = Math.random() < 0.3; // 벽 확률
                    }
                }
            }
            tries++;
        }
    }

    function updateMoveableTiles() {
        const directions = [
            [-1, 0], [1, 0], [0, -1], [0, 1] // 상, 하, 좌, 우
        ];

        for (let row = 0; row < mazeSize; row++) {
            for (let col = 0; col < mazeSize; col++) {
                tiles[row][col].moveable = false;
            }
        }

        for (const [dr, dc] of directions) {
            const newRow = playerPosition.row + dr;
            const newCol = playerPosition.col + dc;
            if (newRow >= 0 && newRow < mazeSize && newCol >= 0 && newCol < mazeSize && !tiles[newRow][newCol].wall) {
                tiles[newRow][newCol].moveable = true;
            }
        }

        drawMaze();
    }

    function move() {
        if (selectedTile) {
            if (selectedTile.row !== undefined && selectedTile.col !== undefined) {
                const tile = tiles[selectedTile.row][selectedTile.col];
                if (tile.moveable) {
                    tiles[playerPosition.row][playerPosition.col].revealed = true;
                    playerPosition.row = selectedTile.row;
                    playerPosition.col = selectedTile.col;

                    if (!tile.revealed) {
                        currentScore += tile.score;
                        document.getElementById('score').textContent = currentScore;
                        if (currentScore > 13) {
                            alert('점수가 13점을 넘었습니다. 출발지로 돌아갑니다.');
                            playerPosition.row = 0;
                            playerPosition.col = 0;
                            currentScore = 0;
                            document.getElementById('score').textContent = currentScore;
                        }
                    }

                    playerHealth--;
                    document.getElementById('health').textContent = playerHealth;

                    if (playerHealth <= 0) {
                        endGame(false);
                        return;
                    }

                    tiles[playerPosition.row][playerPosition.col].revealed = true;
                    updateMoveableTiles();
                    drawMaze();
                    checkGameOver();
                } else {
                    alert('이동할 수 없는 타일입니다.');
                }
            } else {
                alert('선택된 타일이 유효하지 않습니다.');
            }
            document.getElementById('optionContainer').style.display = 'none';
            selectedTile = null;
        }
    }

    function useHint() {
        if (hintsAvailable > 0) {
            hintsAvailable--;
            document.getElementById('hints').textContent = hintsAvailable;
            tiles[endTile.row][endTile.col].moveable = true; // 힌트로 끝 위치를 밝힘
            drawMaze();
            setTimeout(() => {
                tiles[endTile.row][endTile.col].moveable = false; // 힌트 표시 해제
                drawMaze();
            }, 2000);
        }
    }

    function cancel() {
        document.getElementById('optionContainer').style.display = 'none';
        selectedTile = null;
    }

    function endGame(success) {
        const gameStatus = document.getElementById('gameStatus');
        if (success) {
            gameStatus.textContent = "성공!";
            gameStatus.style.color = "green";
        } else {
            gameStatus.textContent = "실패!";
            gameStatus.style.color = "red";
        }
        canvas.removeEventListener('click', onClick);
    }

    function onClick(event) {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const col = Math.floor(x / tileSize);
        const row = Math.floor(y / tileSize);

        if (row >= 0 && row < mazeSize && col >= 0 && col < mazeSize) {
            const tile = tiles[row][col];
            if (tile.moveable) {
                selectedTile = { row, col };
                const optionContainer = document.getElementById('optionContainer');
                optionContainer.style.left = `${event.clientX}px`;
                optionContainer.style.top = `${event.clientY}px`;
                optionContainer.style.display = 'flex';
            }
        }
    }

    canvas.addEventListener('click', onClick);
    initializeMaze();
</script>
</body>
</html>
